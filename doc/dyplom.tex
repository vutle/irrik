%% Marcin Załuski - praca dyplomowa
%%
%% http://www.immt.pwr.wroc.pl/index.php?option=com_docman&task=down&bid=75 - instrukcja do szablonu
%%
%% mwrep:
%% 	sudo apt-get install texlive-lang-polish 
%% textpops
%%	sudo apt-get install texlive-latex-extra
%%
%% *.sty do katalogu:
%% 	mkdir -p ~/texmf/tex/latex/pwr
%% 	texhash ~/texmf
%% 	sudo updmap

\newcommand{\cmnt}[1]{}
\documentclass[11pt]{mwrep}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{pwrdtyt}
\usepackage{url}
\usepackage{graphicx}
\usepackage{lineno}
\usepackage{array}
\usepackage[dvips, pdfborder={0}, bookmarks, colorlinks=false, pdftitle={Animacja 3D z wykorzystaniem kinematyki odwrotnej}, pdfauthor={Marcin Załuski}, pdfsubject={Animacja 3D z wykorzystaniem kinematyki odwrotnej}, pdfkeywords={Animacja, 3D, kinematyka odwrotna, Irrlicht}]{hyperref}
\renewcommand{\baselinestretch}{1.5}
\usepackage[a4paper]{geometry}
\author{Marcin Załuski}
\title{Animacja 3D z wykorzystaniem kinematyki odwrotnej}
\promotor{dr inż. Tomasz Kapłon}
\wydzial{Elektronika}
\kluczowe{animacja, 3D, kinematyka, odwrotna, gra, silnik graficzny, ruch, postać}
\streszczenie{Streszczenie pracy}

\begin{document}
\maketitle
\tableofcontents
\linenumbers
\chapter{Wprowadzenie}

Parę słów po co, gdzie i do czego jest animacja stosowana, jak to mamy coraz lepszy sprzęt itp

  \section{Określenie problemu}

  Nieco bliższe przedstawienie problemu animacji i kinematyki odwrotnej

  \section{Cel pracy}
  Aby ukierunkować rozwój pracy i określić charakter badań, które zostaną przeprowadzone w trakcie jej tworzenia, konieczne jest ustalenie celu, który student zamierza poprzez nią osiągnąć. Takie też było pierwsze zadanie, jakie postawił przed sobą autor tejże pracy. Celem niniejszego dzieła jest analiza porównawcza metod animacji trójwymiarowej. Efektem tego ukierunkowania była możliwość wybrania oraz zastosowania odpowiedniej dla niego metodologii badawczej.

  \section{Etapy oraz zakres pracy}

  Obszar, jaki zajmuje problematyka dotycząca animacji komputerowej, a w szczególności animacji trójwymiarowej jest bardzo rozległy, a same zagadnienia bywają niezwykle trudne i złożone. Prowadzi to do tego, że zainteresowanym osobom, oferowane jest szerokie pole do badań i rozwoju. Pamiętając o tym, a przede wszystkim mając na względzie przejrzystość pracy, po wcześniejszym przyjęciu odpowiednich założeń, podzielono ją na etapy. W ten sposób nadano przeprowadzanym badaniom odpowiedni kierunek oraz określono ramy, w jakich powinny się one zawierać. Dzięki temu oraz poprzez sprecyzowanie celu, o którym mowa była w poprzednim rozdziale, określenie, w którym momencie niniejsze dzieło może zostać uznane za zakończone, było w znacznym stopniu ułatwione.
  
  Aspektem inżynierskim tej pracy jest opracowanie animacji w przestrzeni trójwymiarowej obiektów, których ruch oparty jest o algorytm kinematyki odwrotnej. Jako aspekt badawczy natomiast, określone zostało zastosowanie algorytmu kinematyki odwrotnej do tworzenia animacji w przestrzeni trójwymiarowej, a także zbadanie przydatności oraz efektywności wykorzystania tejże kinematyki.

  Jak już wspomniano powyżej, praca została podzielona na etapy. Zabieg ten ułatwić miał rozeznanie się w osiąganych postępach oraz wcześniejsze nakreślenie odpowiedniego harmonogramu. Kroki, obrane przy realizacji pracy wyglądają, jak następuje:

  \begin{enumerate}

  \item Przegląd literatury
  \item Opracowanie koncepcji rozwiązania
  \item Modelowanie aktywnych obiektów sceny
  \item Opracowanie zestawu animacji z wykorzystaniem kinematyki odwrotnej
  \item Przygotowanie platformy testowej
  \item Implementacja algorytmu kinematyki odwrotnej dla aktywnych obiektów sceny
  \item Weryfikacja poprawności i jakości wizualnej ruchu na platformie testowej
  \item Analiza, opracowanie i interpretacja wyników
  \item Redakcja pracy

  \end{enumerate}

  \section{Struktura pracy}

  W drugim rozdziale niniejszego dzieła poruszone zostały zagadnienia, które bezpośrednio dotyczą tematu animacji komputerowej. Przybliżono w nim szereg różnych terminów, których znajomość i zrozumienie są niezbędne, aby móc w pełni pojąć dalszą część tejże pracy. Przykładem takiego terminu jest choćby system szkieletowy.

  Rozdział trzeci natomiast, w całości został poświęcony badanemu zagadnieniu, jakim jest kinematyka odwrotna, ze szczególnym uwzględnieniem jej zastosowania na płaszczyźnie trójwymiarowej animacji komputerowej.
  
  W kolejnym, czwartym rozdziale zawarto szczegóły dotyczące projektu, który został zrealizowany na potrzeby tej pracy. Na początku tejże części przedstawiono założenia, jakie autor przyjął przed przystąpieniem do wykonania projektu. Następnym etapem było dokonanie przeglądu, a wreszcie wybór technologii, które zostały później wykorzystane przy realizacji projektu. Detale oraz uwagi dotyczące implementacji zrealizowanego projektu przedstawiono na końcu rozdziału.

  W piątym rozdziale, autor poświęcił się deskrypcji i specyfikacji badań, które zostały wykonane na potrzeby jego pracy. W tej części znalazły się także otrzymane w przebiegu tychże badań wyniki.

  Ostatni, szósty rozdział pozostawiono na podsumowanie przeprowadzonych badań, ich wyników oraz niniejszego dzieła jako całości. Przedyskutowano w nim między innymi osiągnięte rezultaty, a także określono możliwe perspektywy dla dalszych prac badawczych.

\chapter{Animacja 3D}

Wyjaśnienie terminów związanych z animacją itp, opis różnych metod, algorytmy, rysunki poglądowe...
co to jest kinematyka

%włosy odzież mięśnie napięcie emocje itp TODO
  \section{Kinematyka prosta}

  Słowo kinematyka wywodzi się od greckiego słowa \textit{kín\={e}ma}, które to oznacza ruch. Kinematyka jako dział fizyki zajmuje się zatem badaniem ruchu, ale bez uwzględnienia sił, przez działanie których ruch ten został wywołany. Ponieważ niniejsza praca traktuje o kinematyce odwrotnej, wypadałoby zatem już w tym miejscu wyjaśnić, w stosunku do czego jest ona odwrotna. Otóż jest ona odwrotna do \texttt{kinematyki prostej}. Za tym niezwykle banalnym pojęciem kryje się bardzo prosta koncepcja. Polega ona na poddawaniu sukcesywnym przekształceniom kolejnych części łańcucha kinematycznego, aż do osiągnięcia pozycji docelowej, bądź do niej możliwie najbliższej, jeśli pozycja docelowa miałaby okazać się nieosiągalna. Dla przykładu, jeśli chcemy aby animowana postać podniosła rękę, należy odpowiednio ustawić staw barkowy, aby przedramię osiągnęło właściwą pozycję, a następni tę samą czynność trzeba wykonać dla stawu łokciowego. Kinematyka prosta została zilustrowana na rys. \ref{img:fk} Wynika z niego, że w tym przypadku mamy do czynienia z bezpośrednim sterowaniem każdej części ruchomego systemu, takiego jak dla przykładu szkielet ludzki.

  \begin{figure}
  \centering
    \includegraphics[keepaspectratio=true,width=\linewidth]{./img/fk.png}
  % fk.png: 298x271 pixel, 90dpi, 8.41x7.65 cm, bb=0 0 238 217
  \caption{Kinematyka prosta}
  \label{img:fk}
  \end{figure}

  \section{Kinematyka odwrotna}

  Kinematyka odwrotna, jak łatwo się domyślić, polega na odwróceniu procedury opisanej w punkcie poprzednim. Taki zabieg sprawia, że konieczność każdorazowej manipulacji elementami składowymi ruchomego układu, zostaje wyeliminowana. Bardziej wnikliwe studium rzeczonej metody animacji zostanie przedstawione w dalszej części niniejszej pracy.

  \section{animacja szkieletowa}
  \section{animacja klatkowa}
  \section{animacja ...}
  
\chapter{Kinematyka odwrotna}

Kinematyka odwrotna jest metodą, którą od dawna stosuje się w dziedzinie automatyki i robotyki, do sterowania różnego rodzaju manipulatorami i kończynami robotów, w tym robotów autonomicznych. Nieco później, z dużym powodzeniem tej metody, kinematyką odwrotną zainteresował się przemysł filmowy. Ze względu na niewielką ilość czynności koniecznych do osiągnięcia zamierzonego przez grafików efektu, przyczynia się ona do przyspieszenia procesu animowania komputerowo wygenerowanej postaci. Obecnie kinematyka odwrotna stosowana jest na bardzo szeroką skalę w różnych dziedzinach naukowo-rozrywkowych, w tym w przemyśle gier komputerowych, na przykład do animacji modeli w czasie rzeczywistym.

W rozdziale tym dokonano bliższego niż w poprzednich częściach tej pracy przedstawienia istotnego zagadnienia, za jakie uznaliśmy kinematykę odwrotną. Opisano w nim pokrótce historię powstania tejże techniki, dokonano jej formalnej definicji oraz nieco bliżej przedstawiono kilka wybranych, dotyczących jej algorytmów.

%  Konkretniejszy opis IK niż w poprzednim rozdziale. Historia i geneza, opis zastosowań i paru algorytmów, ze szczególnym uwzględnieniem implementowanego CCD.

  \section{Geneza i zastosowania}

  Kiedy zaczęto projektować pierwsze na świecie roboty z ruchomymi ramionami, pojawił się także problem sterowania konstrukcjami tego typu. Tak powstała teoria sterowania, będąca poddziedziną robotyki i automatyki. Ze względu na stosowanie mikrokontrolerów, które to są taktowane znacznie niższymi częstotliwościami, niż klasyczne komputery i charakteryzują się ograniczoną mocą obliczeniową. Mając to na uwadze, oczywistym staje się fakt, że problem sterowania robotów stał się niezwykle istotnym polem badań. Starania miały na celu opracowanie rozwiązania o jak najniższej złożoności obliczeniowej oraz zachowującego możliwie wysoką precyzję w odwzorowaniu naturalnych ruchów

  \textit{Li-Chun Tommy Wang} wraz z \textit{Chih Cheng Chenem} w \cite{ikrobot} zaproponowali koncepcję rozwiązania problemu sterowania robotem, którą rozwinął \textit{Chris Welman} w \cite{welman}. 

  aplikacje blender itp, nowe algorytmy, scopus
\section{Formalna definicja problemu}

 Niech zadany będzie łańcuch kinematyczny długości $n$ zakończony manipulatorem \textbf{N} (ostatni z $n$ elementów składowych łańcucha). Przyjmując, że $\bf\vec{v}$ jest to wektor określający docelową pozycję manipulatora \textbf{N} w trójwymiarowej przestrzeni kartezjańskiej, natomiast $\bf\vec{s}$ definiując jako wektor stanu rozważanego układu, kinematykę prostą można sformułować jako funkcję $f$:
$$
\bf\vec{v} = f(\bf\vec{s})
$$
Dodatkowo, jeżeli określimy $P_i$ jako macierz przekształceń składowej $a_i$ zadanego łańcucha kinematycznego, funkcja $f$ może zostać rozwinięta do:

$$
{\vec{v}} = P_1a_1({s_1})P_2a_2({s_2}) \dots P_na_n({s_n})
$$
Problemem, który okazuje się łatwiejszym do rozwiązania, może być po prostu znalezienie funkcji odwrotnej do $f$, którą to określono jako kinematyka odwrotna:

$$
f^{-1} (\vec{v})  = \vec{s}
$$


  \section{Przegląd publikacji}

W tym podrozdziale zawarto krótki opis poszukiwań przeprowadzonych, których celem było rozeznanie się w aktualnym stanie wiedzy, jak i zbadanie popularności tematu kinematyki odwrotnej.

Mój tzw. Systematic literature review i notatki po ang. do przetłumaczenia, ogarnięcia i uzupełnienia.



    Your query:   TITLE-ABS-KEY((inverse kinematics OR reverse kinematics) AND 3d) AND SUBJAREA(comp OR phys) AND (LIMIT-TO(SUBJAREA, "COMP") OR LIMIT-TO(SUBJAREA, "MULT")) Document results: 153 

many non related publications:

(e.g. Synthetic echocardiographic image sequences for cardiac inverse electro-kinematic learning     Prakosa, A., Sermesant, M., Delingette, H., Saloux, E., Allain, P., Cathier, P., Etyngier, P., (...), Ayache, N.     2011     Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics) 6891 LNCS (PART 1), pp. 505-507,

Protein loop closure using orientational restraints from NMR data     Tripathy, C., Zeng, J., Zhou, P., Donald, B.R.     2011     Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics) 6577 LNBI, pp. 483-498     0  )

        Heuristic solution for constrained 7-DOF motion planning in 3D scanning application
        Intuitive interactive human-character posing with millions of example poses


    Your query:   TITLE-ABS-KEY(((inverse kinematics OR reverse kinematics) AND animation) OR ((inverse kinematics OR reverse kinematics) AND motion)) AND SUBJAREA(comp) AND (LIMIT-TO(EXACTKEYWORD, "Three dimensional")) AND (LIMIT-TO(DOCTYPE, "ar"))
      Document results: 16

\begin{enumerate}
 \item Natural character posing from a large motion database - novel IK solution NAT-IK (2011)
 \item Wearable sensors for 3D upper limb motion modeling and ubiquitous estimation - not closely related
 \item      Ambulatory estimation of muscle forces of lower limbs in a Rehabilitation robot system - not closely related
\item        Evaluation of a geometry-based knee joint compared to a planar knee joint - not closely related
\item        Adding image constraints to inverse kinematics for human motion capture - inverse kinematics applied to markerless motion capture process. Related, but not so much.
\item        A biomimetic approach to inverse kinematics for a redundant robot arm - consider evaluating proposed IK algorithm for 3d animation (2010)
\item         An interactive motion-editing method for human animation - Focused on motion-editing.
\item         An off-line robot simulation toolbox - not closely related
        \item Automatic reconstruction of 3D human motion pose from uncalibrated monocular video sequences based on markerless human motion tracking - yet another markerless human motion tracking involving IK.
\item         Hand modeling and motion controlling based on lay figure in virtual assembly - hand animation
\item         Research on kinematics simulation of maintenance and inspection robot in nuclear power plants	 - robot simulation
\item         Full-body performance animation with Sequential Inverse Kinematics - Sequential IK, algorithms comparsion study
\item         Evaluating the influence of induced passive torques in the simulation of time-varying human poses
\item         A scalable model-based hand posture analysis system
\item         A cell decomposition-based collision avoidance algorithm for robot manipulators
\item         Algebraic methods for image processing and computer vision
\end{enumerate}


remark- use exact IK keyword in scopus - prev results include I and K not as a one phrase
consider looking for IK algorithms

  \section{Metody kinematyki odwrotnej}

    TODO


    \subsection{Transpozycja Jakobianu}

     TODO
 
    \subsection{Cyclic-Coordinate Descent}
  Metoda ta, w skrócie nazywana \texttt{CCD}, należy do klasy metod zwanych metodami heurystycznymi. Idea kryjąca się za tym sposobem rozwiązywania zadania kinematyki odwrotnej polega na analitycznym podejściu do szeregu znacznie prostszych problemów. W pierwszej i w każdej kolejnej iteracji poszukiwane są parametry, dla których zadana funkcja przyjmuje wartość minimalną przy spełnieniu określonych kryteriów. Wspomniana funkcja jest znacznie mniej złożona i cechuje się o wiele niższym stopniem komplikacji obliczeniowej w porównaniu z podejściem w pełni analitycznym.

\chapter{Projekt}

  \section{Założenia}

  \section{Przegląd i wybór technologii}
    Przed przystąpieniem do realizacji jakiegokolwiek projektu wysoce wskazane jest, aby rozważyć możliwość i zasadność zastosowania różnego typu narzędzi oraz technologii. Dzięki takiemu podejściu możliwe jest zminimalizowanie czasu potrzebnego na ukończenie danego projektu. Inną istotną zaletą przeprowadzania wstępnej analizy dostępnych rozwiązań, jest również znacznie wyższe prawdopodobieństwo, że jakość ukończonego z ich pomocą projektu, będzie o wiele wyższa i lepsza.

    W niniejszym podrozdziale dokonano przeglądu istniejących narzędzi i technologii pod kątem wykorzystania ich w tym projekcie. Na początku znajduje się wprowadzenie w tematykę najbardziej przydatnych i koniecznych narzędzi, jakimi są silniki graficzne. W dalszej kolejności przedstawiono kryteria, jakimi kierowano się przy podejmowaniu wyboru oraz opisano trzy rozważane przez autora rozwiązania. Część ta kończy się krótkim podsumowaniem i uzasadnieniem, dlaczego wybrane zostały takie, a nie inne rozwiązanie. Na zakończenie tego podrozdziału przybliżono, bez zbytniego zagłębiania się w szczegóły, dwa popularne dla sprzętu graficznego interfejsy programowe.


    \subsection{Silnik Graficzny}

    Bez wykorzystania mocnych silników graficznych, prawdopodobnie nie powstałyby wielkie, wy\-so\-ko\-bud\-że\-to\-we produkcje, jakie obecnie i od lat ukazują się na rynku gier komputerowych . Wiąże się to ze stale rosnącym, wysokim stopniem skomplikowania układów graficznych, coraz większym poziomem realizmu oraz wykorzystaniem bardziej zaawansowanych efektów wizualnych, takich jak \texttt{HDR}, czy efekty cząsteczkowe.

    Obecnie na rynku dostępnych jest wiele zróżnicowanych silników graficznych, urozmaiconych pod wieloma względami i prezentujących ogromną liczbę indywidualnych cech oraz funkcjonalności. Dzięki ich zastosowaniu, programiści mogą się skupić na implementacji innych, unikalnych dla danej gry elementów, takich jak choćby logika czy system rozwoju postaci. Wiąże się to z oszczędnością czasu pracy i optymalizacją wykorzystywanych zasobów. Ponadto powszechnym zjawiskiem jest, że firmy na bazie jednego silnika wydają kilka różnych produkcji w dość krótkim czasie. Takie zjawisko nie byłoby możliwe, gdyby przy tworzeniu każdej, pojedynczej gry, konieczna była obsługa programowego interfejsu dla sprzętu graficznego od podstaw. Co więcej, częstokroć bywa tak, że producent nie posiada silnika graficznego, ani nie zamierza rozwijać jego bazy od samego początku, lecz zwyczajnie używa już dostępnego. Zazwyczaj dzieje się tak w przedsięwzięciach amatorskich, hobbystycznych, niskobudżetowych, lub badawczych, jakkolwiek nie jest to regułą. W wymienionych wyżej projektach, głównie ze względów finansowych wybór przeważnie pada na darmowe rozwiązania otwartoźródłowe.


    Przykładem komercyjnego silnika, wykorzystywanego w licznych uznanych, dużych i popularnych produkcjach niezależnych firm, może być \texttt{RenderWare}. Jest to produkt studia \textit{Criterion}, które było częścią firmy \textit{Canon}. Został on użyty przy tworzeniu takich tytułów jak \textit{Tony Hawk's Pro Skater 3}, \textit{Battlefield 2: Modern Combat}, czy choćby słynnej serii \textit{Grand Theft Auto} oraz wielu, wielu innych -- obszerna lista wykorzystujących go produktów jest dostępna na \cite{renderware:list}. Wymienione gry wydane zostały kolejno przez firmy \textit{Neversoft/Activision}, \textit{DICE}, \textit{Rockstar Games}. Można zauważyć, że są to światowej sławy spółki, co świadczy o prestiżu silnika RenderWare, o którym więcej można się dowiedzieć na \cite{renderware}. Niestety po wykupieniu praw do niego przez \textit{Electronic Arts} dystrybucja licencji oraz rozwój silnika zostały wstrzymane.


    W związku z faktem, iż nawet najwięksi wydawcy gier stosują w swoich produktach zewnętrzne rozwiązania oraz biorąc pod uwagę zakres i czas ograniczony terminem złożenia pracy dyplomowej, również w tym projekcie postanowiono użyć już istniejącego silnika graficznego. W dalszej części rozdziału przedstawione zostaną kryteria i wymogi jakie autor postawił przed poszukiwanym silnikiem oraz pokrótce opisano inne, także rozważane możliwości. Na koniec znajdzie się uzasadnienie ostatecznej decyzji, która została podjęta przy wyborze silnika graficznego.


    Głównym kryterium, którym kierowano się przy wyborze, była licencja, na której opublikowany został dany silnik graficzny. Ze względu na naukowy i niedochodowy charakter projektu, rozwiązanie, którego poszukiwano, powinno być o otwartych źródłach, a co za tym idzie, o licencji zgodniej z \texttt{GPL}/\texttt{BSD}, bądź do niej zbliżonej. Kolejnym istotnym wymogiem były obsługiwane platformy sprzętowo-sys\-te\-mo\-we, jako że projekt rozwijany był przy wykorzystaniu systemu operacyjnego \texttt{GNU/Linux} i mikrokomputera o architekturze \texttt{x86}. Kluczowa była także możliwość użycia danego silnika graficznego w aplikacji pisanej w języku programowania \texttt{C/C++}. Ponadto ze względu na presję, jaką wywierał termin złożenia pracy, poszukiwano rozwiązania o stosunkowo łagodnej krzywej uczenia. W związku z tym, za duży atut uważano również popularność silnika, a także ilość oraz jakość dostępnej dokumentacji i materiałów dydaktycznych. Z tego samego powodu za istotną uznano dużą osiągalność materiałów gotowych i dozwolonych do użycia, takich jak sceny i modele postaci. To z kolei przekłada się na ilość i rodzaj obsługiwanych przez dany silnik graficzny formatów wejściowych. Biorąc pod uwagę postawiony cel, implementację algorytmu kinematyki odwrotnej, wykorzystanie systemu szkieletowego przyjęto za bardzo ważne kryterium. Zwrócono również uwagę na to, aby silnik graficzny nie posiadał jeszcze metod kinematyki odwrotnej. Za drugorzędne, bądź dużo mniej istotne uznano takie cechy jak jakość renderowanej grafiki i możliwość użycia shaderów oraz zaawansowanych efektów specjalnych czy oświetleniowych.

 
      \subsubsection{OGRE}
 
      OGRE to popularny silnik graficzny, oparty na wolnej licencji \texttt{MIT}, która to jest kompatybilna z licencją \texttt{GPL}. Nazwa silnika jest skrótem od angielskiego \textit{Object-Oriented Graphics Rendering Engine}, co w języku polskim oznacza Zorientowany Obiektowo Silnik Renderujący Grafikę.

      OGRE, jak większość szeroko stosowanych silników graficznych, został napisany w języku \texttt{C++}. Wszelkie szczegóły dotyczące implementacji niższych warstw, takich jak wywołania API \texttt{OpenGL} lub \texttt{Direct3D}, podlegają hermetyzacji dzięki użyciu klas. Daje to możliwość szybkiego osiągnięcia zamierzonych rezultatów bez konieczności szczegółowego zapoznawania się ze specyfiką konkretnej biblioteki graficznej oraz ułatwia przenoszenie aplikacji między platformami systemowymi. OGRE, jak już wcześniej wspomniano, wspiera zarówno OpenGL, jak i Direct3D a także główne systemy operacyjne, to jest texttt{Windows}, \texttt{Linux} oraz \texttt{Mac OS X}. Silnik ten oferuje także możliwość użycia programów cieniujących, animacji szkieletowej, skórowania i wiele innych, ciekawych technik.

      Ze względu na dużą popularność tego silnika graficznego, istnieje naprawdę mnóstwo materiałów dydaktycznych dotyczących jego obsługi. Na uwagę zasługują publikacje w formie drukowanych książek. Dobrym przykładem są takie pozycje jak \cite{ogreb1}, czy też najnowsza publikacja dostępna w chwili pisania niniejszej pracy, cechująca się nieco innym podejściem do tematu. Mowa tutaj o \cite{ogreb2}. Na początku pracy z OGRE warto jednak zapoznać się przede wszystkim z materiałami dostępnymi na \cite{ogre}.

      OGRE niestety nie jest szczególnie łatwym w użyciu silnikiem graficznym. Aby zrozumieć filozofię jego działania i programowania aplikacji, należy poświęcić sporo czasu. Wynikowy kod dla prostej sceny również zdaje się być dość rozwlekły. Co prawda, sam silnik nie oferuje metod animacji opartych o kinematykę odwrotną, ale istnieją poboczne implementacje algorytmów IK z użyciem OGRE, które jak dotąd nie zostały włączone do głównego projektu.

      \subsubsection{Panda3D}

      W odróżnieniu od pozostałych rozpatrywanych rozwiązań \texttt{Panda3D} jest projektem dalece bardziej złożonym. Przyczyny takiego stanu rzeczy należy upatrywać w tym, że nie jest to jedynie silnik graficzny, a kompletny silnik gry. W związku z powyższym \texttt{Panda3D} posiada skomplikowaną strukturę oraz podsystemy odpowiedzialne za renderowanie grafiki, animacje, odtwarzanie dźwięku, sterowanie, detekcję kolizji, obsługę sieci, symulacje fizyczne, sztuczną inteligencję i inne.

      Zdecydowanie warto zaznaczyć, że projekt ten powstał jako zamknięte oprogramowanie rozwijane na własne potrzeby przez studio \texttt{Disney VR} będące częścią dobrze wszystkim znanej korporacji \texttt{The Walt Disney Company}. W roku 2002 silnik został opublikowany jako wolne oprogramowanie. Obecnie jego rozwój jest kontynuowany na licencji \texttt{BSD} przez \texttt{Entertainment Technology Center} przy uniwersytecie \texttt{Carnegie Mellon} we współpracy z \texttt{Disneyem}.

      Panda3D jest napisana w języku \texttt{C++} i pozwala na programowanie aplikacji zarówno z użyciem \texttt{Pythona}, jak i \texttt{C++}. Niestety przekłada się to na skomplikowany proces budowania silnika ze źródeł. Dostępne są dwa systemy -- \texttt{ppremake} i \texttt{makepanda}. Pierwszy jest rozbudowany i dostarcza szereg rozmaitych opcji konfiguracyjnych, lecz jest trudniejszy w obsłudze. Drugi natomiast jest rozwiązaniem prostym i pozwalającym szybko zbudować niezbędne moduły bez zagłębiania się w szczegółowe niuanse tegoż procesu.

      Opisywany silnik ma możliwość korzystania z dwóch interfejsów programowych dla sprzętu graficznego -- \texttt{OpenGL} i \texttt{Direct3D}. Pozwala także na używanie programów cieniujących i animacji szkieletowej.

      Dokumentacja projektu jest bardzo dobra. Za pewien mankament można uznać fakt, iż podstawowym i głównie wspieranym językiem jest w tym przypadku \texttt{Python}. Wiąże się to z ukierunkowaniem dokumentacji właśnie na ten język, co można zauważyć na \cite{panda}. Obecnie dostępne są dwie pozycje książkowe w całości poświęcone programowaniu z wykorzystaniem silnika graficznego \texttt{Panda3D}. Podczas gdy \cite{pandab1}, pomimo skupienia na podstawowym języku programowania, zawiera także fragmenty przeznaczone dla programistów C++, tak \cite{pandab2} jest przeznaczona dla osób początkujących w dziedzinie projektowania oraz rozwijania gier i w pełni została napisana została pod kątem Pythona.

      Niestety podczas kompilacji Pandy w stabilnej wersji \textit{1.7.2} napotkano szereg problemów, a proces budowania wielokrotnie kończył się komunikatem błędu. Poszukiwania rozwiązań dla tych problemów na \cite{pandaf} zakończyły się znalezieniem sugestii, aby skorzystać z wersji rozwojowej silnika dostępnej przez repozytorium. Kompilacja tym razem powiodła się, ale problematyczne okazało się uruchomienie dostarczonych przykładów.

      \subsubsection{Irrlicht}

      Silnik ten jest dystrybuowany na licencji \texttt{ZLib}, która to jest zgodna z licencją GPL. Nazwa jest złożeniem niemieckich słów \textit{Irre}, co oznacza zwariowany i \textit{Licht}, czyli światło, co w połączeniu daje błędny ognik. Początki projektu sięgają roku 2002, kiedy Nikolaus Gebhardt rozpoczął prace nad nowym silnikiem graficznym.

      Irrlicht charakteryzuje się łagodną krzywą uczenia i wysoką elastycznością. Silnik został napisany w przejrzysty oraz czytelny sposób w języku \texttt{C++} z użyciem przestrzeni nazw i wzorców projektowych \texttt{GRASP}. Dzięki temu łatwo można zorientować się w jego kodzie źródłowym. Ponadto obok tych wymienionych już zalet, Irrlicht jest wieloplatformowy, stabilny, nie wymaga instalacji dodatkowych bibliotek w systemie oraz działa bardzo szybko.

      Silnik pozwala na użycie zarówno \texttt{OpenGL}, jak i \texttt{Direct3D} oraz własnego programowego mechanizmu renderowania. Na uwagę zasługuje duża ilość standardowo obsługiwanych formatów wejściowych. Otwiera to możliwości, aby bez problemu używać animowanych modeli z gry Quake w wersji 2 i 3 oraz zapisanych w formacie B3D, DirectX, czy Milkshape. Lista obsługiwanych obiektów statycznych jest jeszcze dłuższa i znajduje się na niej m.in. natywny format OGRE, 3d Studio, Alias Wavefront Maya i Lightwave. Dzięki temu możliwe jest skorzystanie z bogatej biblioteki modeli i użycie ich jako obiektów zastępczych do czasu przygotowania własnych. Zwiększa to też liczbę dostępnych do użycia programów służących do modelowania trójwymiarowego. Irrlicht pozwala na zastosowanie animacji szkieletowej, efektów cząsteczkowych, dynamicznego oświetlenia i programów cieniujących. Można z niego korzystać w wielu językach, n.p. C++ C$\sharp$, VisualBasic, Delphi, Java.

       Obecnie na rynku znaleźć można dwie publikacje książkowe traktujące wyłącznie o opisywanym silniku graficznym. Są to \cite{irrlichtb1} i \cite{irrlichtb2}. Obie są pozycjami skierowanymi do początkujących programistów. Dokumentacja dostępna na \cite{irrlichtw} jest przejrzysta i pomocna. Jej wysoką jakość można zawdzięczać faktowi, iż została przygotowana za pomocą popularnego narzędzia \texttt{Doxygen}.

      \subsubsection{Podsumowanie}

      W powyższych trzech punktach pokrótce zostały przedstawione trzy silniki graficzne, których użycie rozważano przy powstawaniu niniejszego projektu. Zebrane zostały podstawowe dane oraz wady i zalety, a następnie przedstawiono je w stabelaryzowanej formie (tab. \ref{tab:silniki}). Wszystkie te koncepty są dojrzałe i godne uwagi oraz oferują możliwość wykorzystania animacji szkieletowej. Dodatkowo są one dostępne na licencjach zgodnych z licencją GPL i cechują się wieloplatformowością, co pozawala na przenoszenie aplikacji między różnymi systemami operacyjnymi. Można w nich korzystać zarówno z OpenGL, jak i Direct3D. Warte uwagi jest to, że są to silniki graficzne cały czas rozwijane, o czym świadczą daty wydań ich najnowszych wersji stabilnych. Po ich analizie i rozważeniu wszystkich za i przeciw, ostatecznie zdecydowano się na użycie trzeciego omawianego tu silnika, to jest Irrlicht. Na taki, a nie inny wybór znaczny wpływ miała prostota użycia i duża liczba obsługiwanych formatów wejściowych oraz bezproblemowa kompilacja. Dzięki użyciu tego silnika graficznego można było szybko uzyskać efekty zadowalające autora pracy. Atutem jest także jego spójność, czytelność kodu źródłowego oraz bardzo dobra dokumentacja i dostępne w pakiecie praktyczne przykłady wraz z obszernymi komentarzami.

\begin{table}[p]

\begin{center}
\footnotesize
\begin{tabular}{|p{3.6cm}||>{\centering}p{3cm}|>{\centering}p{3cm}|>{\centering}p{3cm}|c} 
\cline{2-4}
  \multicolumn{1}{l|}{} & \textbf{OGRE} & \textbf{Panda3D} & \textbf{Irrlicht} & \\ \cline{2-4} \noalign{\smallskip} \cline{1-4}
Producent & Torus Knot Software Ltd & Disney i Carnegie Mellon University & Nikolaus Gebhardt &\\ \cline{1-4}
Licencja &MIT &BSD & ZLib &\\ \cline{1-4}
Systemy operacyjne &Windows, Linux, Mac OS X & Windows, Linux, Mac OS X, FreeBSD & indows, Linux, Mac OS X, Solaris, inne &\\ \cline{1-4}
Rok wydania pierwszej wersji & 2005 & 2004 & 2002 &\\ \cline{1-4}
Data wydania najnowszej wersji &8 maja 2011 & marzec 2011 & listopad 2010 &\\ \cline{1-4}
Ilość materiałów dydaktycznych & duża & średnia & duża &\\ \cline{1-4}
Ilość wydanych książek & 3 & 2 & 2 &\\ \cline{1-4}
Języki programowania & C++, Java, .Net, Python, inne & Python, C++ & C++, C$\sharp$, VisualBasic, Delphi, Java, inne &\\ \cline{1-4}
Animacja szkieletowa & tak & tak & tak &\\ \cline{1-4}
Kinematyka odwrotna & zewnętrzna implementacja & brak & brak &\\ \cline{1-4}
Klasyfikacja użycia & trudne & średnie & proste &\\ \cline{1-4}

  \end{tabular}
\end{center}
  \caption{Zestawienie informacji o silnikach graficznych}
\label{tab:silniki}
\end{table}

     \subsection{Interfejs programowy dla sprzętu graficznego}

      Wykorzystany przez autora do projektu, nad którym pracował, silnik graficzny pozwala na użycie do renderowania zarówno interfejsu Direct3D, jak i OpenGL. Co prawda założenia projektowe ograniczają wybór do tego drugiego, jednak dla pełnego obrazu, w niniejszej pracy postanowiono przedstawić opis obu konkurencyjnych rozwiązań.

      \subsubsection{Direct3D}

      Direct3D jest częścią opracowanej przez firmę \texttt{Microsoft} biblioteki DirectX -- zbioru API służącego do programowania gier. Powszechnie stosuje się go w produktach przeznaczonych dla rodziny systemów operacyjnych Windows, konsolach tejże firmy, a także urządzeniach mobilnych opartych o rozwiązania Microsoftu.
 
      Omawiane API oparte zostało na tak zwanych interfejsach \texttt{COM} (ang. Component Object Model). Interfejsy te są standardem, jaki firma Microsoft wprowadziła w swoim oprogramowaniu. Zwiększa to trudność użycia i zmniejsza czytelność kodu. DirectX jest zamkniętym rozwiązaniem,  w całości kontrolowanym przez Microsoft. Dokumentacja dostępna jest na \cite{dx}.

      \subsubsection{OpenGL}

      Biblioteka ta powstała na bazie \texttt{IRIS GL} rozwijanej przez firmę \texttt{Silicon Graphics}, która swojego czasu była światowym potentatem w dziedzinie grafiki i animacji komputerowej. OpenGL jest standardem otwartym, a pieczę nad jego rozwojem sprawuje \texttt{Khronos Group}. Jest to związek przedsiębiorstw zajmujący się rozwojem otwartych standardów.

      OpenGL jest dostępne na wielu platformach, takich jak Windows, Mac OS X, iPhone, Nintendo, Android, a także systemach operacyjnych z rodziny Unix, w tym Linux. Jest szeroko wykorzystywane w zaawansowanych narzędziach do tworzenia grafiki komputerowej i wizualizacji naukowych. Z dokumentacją biblioteki można zapoznać się na \cite{opengl}.

  \section{Implementacja}

\chapter{Analiza porównawcza}
  \section{Metodologia}
  \section{Eksperymenty}
  \section{Wyniki}

\chapter{Podsumowanie}


\begin{thebibliography}{99}
% \addcontentsline{toc}{section}{Bibliografia}

\bibitem{renderware:list} MobyGames, \textit{Graphics Engine: RenderWare}, \url{http://www.advancedlinuxprogramming.com/alp-folder}
\bibitem{renderware} Criterion Software, \textit{RENDERWARE GRAPHICS}, \url{http://web.archive.org/web/20070105144827/http://www.renderware.com/graphics.asp}
\bibitem{ogreb1} Gregory Junker, \textit{Pro OGRE 3D Programming (Expert's Voice in Open Source)}, Apress 2006
\bibitem{ogreb2} Ilya Grinblat, \textit{OGRE 3D 1.7 Application Development Cookbookt}, Packt Publishing 2011
\bibitem{ogre} Torus Knot Software Ltd, \textit{OGRE -- Open Source 3D Graphics Engine}, \url{http://www.ogre3d.org/}
\bibitem{panda} Carnegie Mellon University, \textit{Panda3D - Free 3D Game Engine} \url{http://www.panda3d.org}
\bibitem{pandab1} Christoph Lang, \textit{Panda3D 1.7 Game Developer's Cookbook}, Packt Publishing 2011
\bibitem{pandab2} Dave Mathews, \textit{Panda3D 1.6 Game Engine Beginner's Guide}, Packt Publishing 2011
\bibitem{pandaf} Carnegie Mellon University, \textit{Panda3D Forums} \url{http://www.panda3d.org/forums/}
\bibitem{irrlichtb1} André Koscianski, \textit{Game Programming with Irrlicht}, CreateSpace 2011
\bibitem{irrlichtb2} Johannes Stein, \textit{Irrlicht 1.7 Realtime 3D Engine Beginner's Guide}, Packt Publishing 2011
\bibitem{irrlichtw} Nikolaus Gebhardt, \textit{Irrlicht Engine - A free open source 3D engine}, \url{http://irrlicht.sourceforge.net}
\bibitem{dx} Microsoft, \textit{Direct3D 10 Graphics}, \url{http://msdn.microsoft.com/en-us/library/windows/desktop/bb205066%28v=vs.85%29.aspx}
\bibitem{opengl} Khronos Group, \textit{OpenGL - The Industry Standard for High Performance Graphics}, \url{http://www.opengl.org/}

\end{thebibliography}

%%Bibliografia
%%http://www.mobygames.com/game-group/graphics-engine-renderware
%%http://web.archive.org/web/20070105144827/http://www.renderware.com/graphics.asp
\end{document}